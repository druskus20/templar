#[macro_use]
extern crate lua_export;

pub(crate) mod config {
    pub(crate) mod rawconfig {
        #[derive(Clone)]
        pub struct RawConfig {}
    }
}

#[lua_export_mod]
mod lua_export_test {
    use std::sync::{Arc, Mutex};

    use crate::config::rawconfig::RawConfig;

    #[lua_export]
    pub fn foo(_config: Arc<Mutex<RawConfig>>) -> Result<String, std::num::ParseIntError> {
        Ok("foo".to_string())
    }

    #[lua_export]
    pub fn bar(
        _config: Arc<Mutex<RawConfig>>,
        _argum: String,
    ) -> Result<(), std::num::ParseIntError> {
        "bar".to_string();
        Ok(())
    }

    #[cfg(test)]
    mod tests {
        use super::{gen_lua_wrapper, register_lua_api};
        use std::sync::{Arc, Mutex};

        #[test]
        fn test_lua_export() {
            let lua = rlua::Lua::new();
            let config = Arc::new(Mutex::new(super::RawConfig {}));
            register_lua_api(config, &lua).unwrap();

            let root = tempdir::TempDir::new("test_lua_export").unwrap();
            let path = root.path().join("lib.lua");
            gen_lua_wrapper(&path).unwrap();
            let contents = std::fs::read_to_string(&path).unwrap();
            let expected = indoc::indoc!(
                "-- This file is automatically generated, changes will likely be overriden.

                local M = {}

                function M.foo()
                    return foo()
                end

                function M.bar(_argum)
                    return bar(_argum)
                end

                return M
                "
            );
            assert_eq!(contents.trim(), expected.trim());
        }
    }
}
