extern crate proc_macro;
use core::panic;

use proc_macro::TokenStream;
use quote::{quote, ToTokens};
use syn::parse_macro_input;
use syn::{Ident, Item, ItemFn, ItemMod, ReturnType};

// Does nothing, just removes the annotation
#[proc_macro_attribute]
pub fn lua_export(_attr: TokenStream, item: TokenStream) -> TokenStream {
    item
}

#[proc_macro_attribute]
pub fn lua_export_mod(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let mut mod_ast = parse_macro_input!(item as ItemMod);

    if let Some((_, mod_items)) = &mut mod_ast.content {
        // Gets the signatures that are marked with the #[lua_export] attribute
        let function_signs = get_export_functions(mod_items);
        // Generate the code
        let create_lua_wrapper = gen_create_lua_wrapper(&function_signs).unwrap();
        let register_lua_api = gen_register_lua_api(&function_signs).unwrap();
        mod_items.push(create_lua_wrapper.into());
        mod_items.push(register_lua_api.into());
    } else {
        panic!("lua_export_mod: can't add function array to the module");
    };

    mod_ast.into_token_stream().into()
}

// Filters a list of mod items and returns a list of FunctionSignature for the functions
// that are marked with the #[lua_export] attribute
fn get_export_functions(mod_items: &[Item]) -> Vec<FunctionSignature> {
    mod_items
        .iter()
        .filter_map(|item| {
            // Get only functions
            let fun = match item {
                syn::Item::Fn(f) => f,
                _ => return None,
            };

            // Get functions marked with the #[lua_export] attribute
            if fun
                .attrs
                .iter()
                .any(|attr| attr.path.is_ident("lua_export"))
            {
                Some(FunctionSignature::from(fun.clone()))
            } else {
                None
            }
        })
        .collect::<Vec<FunctionSignature>>()
}

// Generates the `create_lua_wrapper` function from a list of FunctionSignature
fn gen_create_lua_wrapper(function_signs: &[FunctionSignature]) -> Result<ItemFn, syn::Error> {
    // "file.write("function M.name(...) end")
    let write_lua_functions_tokens = function_signs
        .iter()
        .map(|sign| {
            // Concatenated argument string
            let args = &sign
                .args
                .iter()
                .map(|arg| arg.to_string())
                .collect::<Vec<_>>()
                .join(", ");

            let lua_function_str = format!(
                "function M.{}({})\n    return {}({})\nend\n\n",
                sign.name, args, sign.name, args
            );

            quote!(
                file.write_all(#lua_function_str.as_bytes())?;
            )
        })
        .collect::<Vec<_>>();

    syn::parse2(quote!(
        pub fn gen_lua_wrapper(path: impl AsRef<std::path::Path>) -> std::result::Result<(), std::io::Error> {
            use std::io::Write;
            let mut file = std::fs::File::create(path)?;
            file.write_all(
                b"-- This file is automatically generated, changes will likely be overriden.\n\n",
            )?;
            file.write_all(b"local M = {}\n\n")?;
            #(#write_lua_functions_tokens)*
            file.write_all(b"return M\n")?;
            Ok(())
        }
    ))
}

// Generates the `register_lua_api` function from a list of FunctionSignature
fn gen_register_lua_api(function_signs: &[FunctionSignature]) -> Result<ItemFn, syn::Error> {
    let create_functions_tokens = function_signs
        .iter()
        .map(|sign| {
            let function_name_str = &sign.name.to_string();
            let function_name = &sign.name;
            let args = &sign.args;
            quote!(
                globals.set(#function_name_str, lua_context.create_function(|_, (#(#args),*)| #function_name(#(#args),*).to_lua_err())?)?;
            )
        })
        .collect::<Vec<_>>();

    syn::parse2(quote!(
        pub fn register_lua_api(lua: &rlua::prelude::Lua) -> std::result::Result<(), rlua::prelude::LuaError> {
        use rlua::ExternalResult;
            lua.context(|lua_context| {
                let globals =  lua_context.globals();
                #(#create_functions_tokens)*
                rlua::prelude::LuaResult::Ok(())
            })?;
            Ok(())
        }
    ))
}

// Contains the relevant information about a function
struct FunctionSignature {
    name: Ident,
    args: Vec<Ident>,
    _ret: ReturnType,
}

impl From<syn::ItemFn> for FunctionSignature {
    fn from(fun: syn::ItemFn) -> Self {
        let name = fun.sig.ident;
        let args = fun
            .sig
            .inputs // arguments
            .iter()
            .map(|arg| match arg {
                // Match typed arguments like foo: f64 (not self)
                syn::FnArg::Typed(arg) => match arg.pat.as_ref() {
                    // Match the pattern (only simple identifiers like "foo")
                    syn::Pat::Ident(name) => name.ident.clone(),
                    _ => panic!("Unsupported argument pattern"),
                },
                _ => panic!("Unsupported argument type"),
            })
            .collect::<Vec<Ident>>();

        let ret = fun.sig.output;

        Self {
            name,
            args,
            _ret: ret,
        }
    }
}
